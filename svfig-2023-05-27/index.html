<!DOCTYPE html>
<script src="../websent/websent.js"></script><script>
FONT = 'consolas; courier';
USABLE = 0.9;
LINE_SPACING = 1.2;
BACKGROUND = '#ffffee';
FOREGROUND = '#000000';
</script><pre>

Dependency Injection
ğŸ’‰    in Forth   ğŸ’‰
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    May 27, 2023

Introduction
â•â•â•â•â•â•â•â•â•â•â•â•
â¼ What is Dependency Injection?
â¼ OOFda, yet another Forth OO system
â¼ Poke, a Forth Dependency Injection tool
â¼ Can we make this simpler?

What is Dependency Injection?
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â¼ Inversion of Control
â¼ Hollywood Principle, "Don't call us..."
â¼ Indirect rather than direct dependencies

public class Foo {
  private final Bar bar;
  private final Baz baz;
  
  Foo() {
    this.bar = new Bar();
    this.baz = new Baz();
  }
  ...
}
 
Foo foo = new Foo();

public class Foo {
  private final Bar bar;
  private final Baz baz;
  
  Foo(Bar bar, Baz baz) {
    this.bar = bar;
    this.baz = baz;
  }
  ...
}
 
Foo foo = new Foo(new Bar(), new Baz());

@coffee_maker.png
<img src="coffee_maker.png">

@thermosiphon.png
<img src="thermosiphon.png">

@electric_heater.png
<img src="electric_heater.png">

@coffee_all.png
<img src="coffee_all.png">

@pountain.jpg
<img src="pountain.jpg">

Object Oriented Forth
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â¼ Pountain
â¼ In 1996, Brad Rodrigeuz examined 17!
  different OO Forth systems
â¼ SWOOP

CLASS POINT
VARIABLE X
VARIABLE Y
: SHOW ( -- )   X @ . Y @ . ;
: DOT ( -- )   ." Point at " SHOW ;
END-CLASS

OOFda
â•â•â•â•â•
â¼ Every Object starts with a pointer to a vtable
â¼ Classes are objects that include a vtable
â¼ Fixed size vtables
â¼ Messages are words that invoke vtable offsets
â¼ Data fields are accessible only at definition time
â¼ All methods are public + dynamic
â¼ Single Inheritance, no interfaces required

@vtable.png
<img src="vtable.png">

class Point2
  variable x
  variable y
  : .construct ( x y -- ) y ! x ! ;
  : .show   x @ . y @ . ;
  : .dot   ." Point at " this .show ;
end-class

class Point2
  value x
  value y
  : .construct ( x y -- ) to y to x ;
  : .show   x . y . ;
  : .dot   ." Point at " this .show ;
end-class

class Point3 extends Point2
  value z
  : .construct ( x y z -- )
     to z super .construct ;
  : .show   super .show z . ;
end-class

1 2 3 Point3 .new constant p
p .show
=>
Point at 1 2 3

@points.png
<img src="points.png">

class Foo
  value bar
  value baz
  : construct ( bar baz -- ) to baz to bar ;
  ...
end-class
 
Bar .new Baz .new Foo .new constant f

Implementation
â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â¼ Pick a fixed method limit
â¼ Use a global for "this"
â¼ Keep most things in a "classing" vocabulary
â¼ Allocate methods in the "forth" vocabulary

defined? oofda-max-methods 0= [IF]
  100 constant oofda-max-methods
[THEN]
  
vocabulary classing also classing definitions also forth
 
variable 'this   : this ( -- o ) 'this @ ;

variable methods   variable last-method
: new-method ( ".name" -- xt )
   methods @ oofda-max-methods >= throw
   create methods @ , 1 methods +! latestxt
   does> this >r swap ( save this ) 'this ! ( switch it )
         dup last-method ! ( save last method )
         @ cells this @ + @ execute ( invoke method )
         r> 'this ! ( restore this ) ;
: method ( ".name" -- xt )
   current @ >r also forth definitions
   >in @ bl parse find dup if
     nip
   else
     drop >in !  new-method
   then
   previous r> current ! ;

: m# ( "name" -- n ) method >body @ ;
: m: ( "name" ) method drop ;
m: .construct  ( make this 0 )
: m! ( xt n class ) swap 3 + cells + ! ;
: field' ( "name" -- n ) ' >body @ ;

: undefined
   last-method @ 2 cells - ( body> ) this .fallback ;
: error-fallback ( xt -- )
   ." Undefined method: " >name type cr throw -1 ;
: blank-vtable
   oofda-max-methods 0 do ['] undefined , loop ;

create ClassClass
  here 3 cells + ,              ( vtable* )
  0 ,                           ( parent )
  oofda-max-methods 3 + cells , ( size )
  blank-vtable                  ( vtable[] )

: nop-construct ;
m: .fallback   m: .size   m: .grow
m: .vtable   m: .parent   m: .getClass
:noname ( xt n ) this m! ;
m# .setMethod ClassClass m!

: create ( "name" )
   create this .size ,
   does> @ this + ;
: variable ( "name" )
   create this .size , cell this .grow
   does> @ this + ;

: value ( "name" )
   create this .size , cell this .grow
   does> @ this + @ ;
: to ( n -- "name" )
   field' postpone literal postpone this postpone +
   postpone ! ; immediate
: +to ( n -- "name" )
   field' postpone literal postpone this postpone +
   postpone +! ; immediate

: dosuper ( n -- )
   this ClassClass .getClass
     .parent .vtable + @ execute ;
: super ( "method" )
   field' cells postpone literal
   postpone dosuper ; immediate

: : ( "name" ) m# :noname ;
: ;   postpone ; swap
      this .setMethod ; immediate

: defining ( cls -- )
   'this ! current @ also classing definitions ;
m: .new   m: .inherit
: class   create ClassClass .new defining ;
: end-class   previous current ! 0 'this ! ;
: extends   ' execute this .inherit ;
: extend   ' execute defining ;
: ClassClass ( -- cls ) ClassClass ;

extend ClassClass
  : .parent ( -- a ) this cell+ @ ;
  : .setParent ( a -- ) this cell+ ! ;
  : .size& ( -- a ) this 2 cells + ;
  : .size ( -- n ) this .size& @ ;
  : .setSize ( -- n ) this .size& ! ;
  : .grow ( n -- ) this .size + this .setSize ;
  : .vtable ( -- a ) this 3 cells + ;
  : .getClass ( o -- cls ) @ 3 cells - ;
  : .allocate ( n -- a ) here swap allot ;
  : .getName ( -- a n ) this 2 cells - >name ;
  : .getMethod ( n -- xt ) cells this .vtable + @ ;
  : .construct   0 this .setParent
                 cell this .setSize
                 oofda-max-methods 0 do ['] undefined i this .setMethod loop
                 ['] error-fallback [ m# .fallback ] literal this .setMethod
                 ['] nop-construct [ m# .construct ] literal this .setMethod ;
  : .setup ( -- cls ) this .size this .allocate
                      dup this .size 0 fill
                      this .vtable over ! ;
  : .new ( -- cls ) this .setup
                    dup >r .construct r> ;
  : .inherit ( cls -- ) dup this .setParent
                        .size& this .size& oofda-max-methods 1+ cells cmove ;
end-class

Making DI Easier
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â¼ Hooking things up manually is tedious
â¼ Doing setup globally is unscalable
â¼ Could we make it automatic + declarative?

DI Frameworks
â•â•â•â•â•â•â•â•â•â•â•â•â•
â¼ Spring
â¼ Guice
â¼ Dagger
â¼ Dagger 2

Spring
â•â•â•â•â•â•
â¼ Specify dependencies in XML
  - Config doesn't live with code :-(
â¼ Runtime validation + configuration

 &lt;beans>
   &lt;bean id="coffeeMaker" class="CoffeeMaker">
     &lt;constructor-arg ref="heater"/>
     &lt;constructor-arg reg="pump"/>
   &lt;bean>
   &lt;bean id="heater" class="ElectricHeater">
     &lt;constructor-arg reg="pump"/>
   &lt;/bean>
   &lt;bean id="pump" class="Thermosiphon"/>
 &lt;/beans>

Java Annotations
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â¼ Include compile/runtime code annotations
â¼ Syntax aware extensions to language
â¼ Compile time code generators that add classes
â¼ A problem Forth doesn't really have!
  - See IMMEDIATE

public @interface MyAnnotation {
}
  
@MyAnnotation public void method() {
}

public @interface MyAnnotation {
  String name();
  int number();
}
 
@MyAnnotation(name = "Rumplestitskin", number = 123)
MyClass object = new MyClass();

 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD})
 public @interface MyAnnotation {
 }

Guice & Dagger
â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â¼ Guice - Annotation based configuration
           Runtime validation
â¼ Dagger 1 - Partial compile time validation
              Runtime graph composition
â¼ Dagger 2 - Compile time validaiton

/** A coffee maker to brew the coffee. */
public class CoffeeMaker {
  private final CoffeeLogger logger;
  private final Lazy<Heater> heater; // Create a possibly costly heater only when we use it.
  private final Pump pump;
  
  @Inject
  CoffeeMaker(CoffeeLogger logger, Lazy<Heater> heater, Pump pump) {
    this.logger = logger;
    this.heater = heater;
    this.pump = pump;
  }
  
  public void brew() {
    heater.get().on();
    pump.pump();
    logger.log(" [_]P coffee! [_]P ");
    heater.get().off();
  }
}

DI Framework Concepts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â¼ @Inject - Ask for dependencies (and sometimes provide)
             Used in regular code
â¼ @Provides - Provide ambiguous bindings
               Used in modules
â¼ @Module - A "glue" class to contain specializations
             (e.g. a thermosiphon as a pump)
â¼ @Component - Container for modules or implicit modules
                Generated into an instantiable thing
â¼ @Singleton - Global scope annotation
                (other scopes exist)

Poke
â•â•â•â•
â¼ Build DI-framework-like tools on OOFda
â¼ Simplify framework concepts
â¼ Use strings for bindings
â¼ Explicit @Inject for each needed dependency
â¼ Explicit .providesName methods for providings bindings
â¼ Component base class to create module container
â¼ Runtime on demand instantiation

( A coffee maker to brew the coffee. )
class CoffeeMaker
  value logger   value heater   value pump
  m: .provideCoffeeLogger m: .provideHeater m: .providePump
  m: .on m: .off m: .pump m: .isHot?
  : .construct   @Inject CoffeeLogger to logger
                 @Inject Heater to heater
                 @Inject Pump to pump ;
  : .brew   heater .on
            pump .pump
            s" [_]P coffee! [_]P " logger .log
            heater .off ;
end-class
  
class CoffeeMakerModule
  : .provideCoffeeMaker CoffeeMaker .new ;
end-class

( A logger to log steps while brewing coffee. )
class CoffeeLogger
  value logs
  : .construct   30 Array .new to logs ;
  : .log ( a n -- ) String .new logs .append ;
  : .dump   logs .length 0 ?do
               i logs .get .get type cr
            loop cr ;
end-class
  
class LoggerModule
  : .provideCoffeeLogger @Singleton CoffeeLogger .new ;
end-class

( An electric heater to heat the coffee. )
class ElectricHeater
  value logger
  value heating
  : .construct   @Inject CoffeeLogger to logger
                 0 to heating ;
  : .on   -1 to heating
          s" ~ ~ ~ heating ~ ~ ~" logger .log ;
  : .off   0 to heating ;
  : .isHot? ( -- f ) heating ;
end-class
  
class HeaterModule
  : .provideHeater @Singleton ElectricHeater .new ;
end-class

( A thermosiphon to pump the coffee. )
class Thermosiphon
  value logger
  value heater
  : .construct   @Inject CoffeeLogger to logger
                 @Inject Heater to heater ;
  : .pump   heater .isHot? if
              s" => => pumping => =>" logger .log
            then ;
end-class
  
class PumpModule
  : .providePump Thermosiphon .new ;
end-class

( The main app responsible for brewing
  the coffee and printing the logs. )
class CoffeeApp extends Component
  : .construct   super .construct
                 HeaterModule this .include
                 PumpModule this .include
                 LoggerModule this .include
                 CoffeeMakerModule this .include ;
end-class
  
CoffeeApp .new constant coffeeShop
coffeeShop .provideCoffeeMaker .brew
coffeeShop .provideCoffeeLogger .dump

Implementation
â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â¼ Use a global to pass a provider through constructors
   - Keep an array of providing modules
   - save the current one if we nest
â¼ Use IMMEDIATE magic for @Singleton to store a cached
   values inside modules objects data area
â¼ Use .fallback handler for undefined methods to route
   to each provider module in turn
â¼ Count how many providers to avoid bad graphs

variable provider
: do@Inject ( xt -- o ) provider @ swap execute ;
create name-buffer 200 allot  0 value name-length
: 0name   0 to name-length ;
: +name ( a n -- ) dup >r name-buffer name-length + swap cmove
                       r> +to name-length ;
: name ( -- a n ) name-buffer name-length ;
: @Inject ( "name" -- o )
   0name s" [ ' .provide" +name bl parse +name s"  ]" +name
   name evaluate postpone literal postpone do@Inject ; immediate

: do@Singleton ( n -- n )
   this + dup @ if @ rdrop exit then
   r> swap [ here 7 cells + ] literal swap >r >r >r exit
   r> over >r ! r> ;
: @Singleton   this .size postpone literal
               cell this .grow
               postpone do@Singleton ; immediate

class Component
  value providers
  : .construct   50 Array .new to providers ;
  : .include ( m -- ) .new providers .append ;
  : .hasMethod ( m n -- f )
     providers .get ClassClass .getClass .getMethod ['] undefined <> ;
  : .countHasMethod { m -- f }
     0 providers .length 0 do
       m i this .hasMethod if 1+ then
     loop ;
  : .pickHasMethod { m -- provider }
     0 providers .length 0 do
       m i this .hasMethod if i providers .get unloop exit then
     loop -1 throw ;

  : .fallback { xt } xt >body @ { m }
     provider @ { old } this provider !
     m this .countHasMethod { matches }
     matches 1 > if ." Multiple Providers: " xt >name type cr -1 throw then
     matches 1 <> if xt error-fallback then
     m this .pickHasMethod xt execute
     old provider ! ;
end-class

But is it Forthy?
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â¼ This is a LOT of complexity!
   (Even in Java!)
â¼ Singleton vs N is partially the cause
â¼ Forth thrives on singletons
â¼ Forth has a better mechanism!

DEFER / IS

DEFER log
DEFER heater-on
DEFER heater-off
DEFER pump
: brew   heater-on
         pump
         s" [_]P coffee! [_]P " log
         heater-off ;

: console-log ( a n -- ) type cr ;
' console-log IS log
   
DEFER hot?
: thermosiphon
    hot? if s" => => pumping => =>" log then ;
' thermosiphon IS pump

0 value switch
: electric-on   -1 TO switch
                s" ~ ~ ~ heating ~ ~ ~" log ;
: electric-off   0 TO switch ;
' electric-on IS heater-on
' electric-off IS heater-off
' switch IS hot?
 
brew

~ ~ ~ heating ~ ~ ~
=> => pumping => =>
[_]P coffee! [_]P

https://github.com/flagxor/ueforth
            /tree/main/attic/oofda

QUESTIONS?
    ğŸ’‰ 
 Thank you!
