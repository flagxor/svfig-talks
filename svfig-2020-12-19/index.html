<!DOCTYPE html>
<script src="../websent/websent.js"></script><script>
USABLE = 0.9;
FONT = 'Consolas, monospace';
BACKGROUND = '#047';
FOREGROUND = '#fc0';
</script><pre>

     Lisp-y
Data Abstraction
    in Forth
       ðŸ™œ
   Brad Nelson
       ðŸ™œ
December 19, 2020

Introduction
     ðŸ™œ
 â€¢ Lisp pairs as a data abstraction
   â€¢ Closed means of combination
 â€¢ Building a GC in Forth
 â€¢ Mapping, Filtering, Aggregating
 â€¢ Binding and closures

Everything is a pair

(car (cons x y)) = x
(cdr (cons x y)) = y

(cons 1 2)
    =
  ( 1 . 2 )

(cons 1 (cons 2 (cons 3 nil)))
             =
          ( 1 2 3 )

+---+---+
| 1 | o |
+---+-|-+
      v
    +---+---+
    | 2 | o |
    +---+-|-+
          v
        +---+---+
        | 3 |NIL|
        +---+---+

(cons 1 (cons 2 3))
             =
          ( 1 2 . 3 )

((1 1) (2 4) (3 9) (4 16))

( x y )  pair  ( p )
  ( p ) unpair ( x y )

Garbage Collection
        ðŸ™œ
 â€¢ Mark and Sweep
 â€¢ Stop and Copy
 â€¢ Hybrid & Generational
 â€¢ Boehm (Conservative)

Stop and Copy
      ðŸ™œ
 â€¢ Cheney 1970
 â€¢ From/To Space
 â€¢ Repack live objects
 â€¢ Leave "broken-hearts"

Blackboard

Very Small

1000000 constant pair-count
: pairs ( n -- n ) 2* cells ;
pair-count pairs 2* allocate throw constant pair-heap
variable pair-brk   variable pair-base
pair-heap pair-base !
 ðŸ™œ
: car ( p -- n ) @ ;        : car! ( n p -- ) ! ;
: cdr ( p -- n ) cell+ @ ;  : cdr! ( n p -- ) cell+ ! ;
 ðŸ™œ
: pair+? ( p -- f )
  pair-heap - dup 0>= swap pair-count pairs 2* < and ;
: pair? ( p -- f )
  pair-base @ - dup 0>= swap pair-count pairs < and ;
: old? ( p -- f) dup pair+? swap pair? 0= and ;
 ðŸ™œ
defer gc   create nil   : null? nil = ;
: full? ( -- f ) pair-brk @ pair-count >= ;
: reserve   full? if gc then ;
: pair-rel ( n -- p ) pairs pair-base @ + ;
: pair-allot ( -- p ) pair-brk @ pair-rel 1 pair-brk +! ;
: pair ( x y -- p )
  reserve pair-allot dup dup >r >r cdr! r> car! r> ;
: cons pair ;
: unpair ( p -- x y ) dup car swap cdr ;

: bind ( a xt -- p ) pair ;
: invoke ( p/a -- ) begin dup pair? while unpair repeat execute ;
 ðŸ™œ
: foreach' ( l op -- last )
  begin over pair? while dup >r >r unpair
    r> swap >r invoke r> r> repeat drop ;
: foreach ( l op -- ) foreach' null? 0= throw ;
 ðŸ™œ
variable roots   nil roots !
: +root ( a -- ) roots @ pair roots ! ;
: root value lastxt >body +root ;
variable broken-heart
: relocate ( a -- )
  dup @ unpair pair over @ broken-heart over car! over swap cdr! swap ! ;
: conserve ( a -- )
  dup @ car broken-heart = if dup @ cdr swap ! else relocate then ;
: preserve ( a -- ) dup @ old? if conserve else drop then ;
: newfixup1 ( n -- ) dup pair-rel dup preserve cell+ preserve 1+ ;
: newfixup 0 begin dup pair-brk @ < while newfixup1 repeat drop ;
 ðŸ™œ
: rpwalk rp@ rp0 @ swap - cell / 0 ?do rp@ i cells + preserve loop ;
: spwalk depth 0 ?do sp@ i cells + preserve loop ;
: rootwalk roots preserve roots @ ['] preserve foreach ;
: newspace   0 pair-brk !   pair-base @ pair-heap =
  if pair-heap pair-count pairs + else pair-heap then pair-base ! ;
: collect   newspace rpwalk spwalk rootwalk newfixup
            full? if abort" heap full" then ;
' collect is gc   : used pair-brk @ ;

Allocation

1000000 constant pair-count
: pairs ( n -- n ) 2* cells ;
pair-count pairs 2* allocate
  throw constant pair-heap
variable pair-brk   variable pair-base
pair-heap pair-base !

: car ( p -- n ) @ ;
: cdr ( p -- n ) cell+ @ ;

: car! ( n p -- ) ! ;
: cdr! ( n p -- ) cell+ ! ;

: pair+? ( p -- f )
  pair-heap - dup 0>= swap pair-count pairs 2* < and ;
: pair? ( p -- f )
  pair-base @ - dup 0>= swap pair-count pairs < and ;
: old? ( p -- f) dup pair+? swap pair? 0= and ;

Collection

defer gc   create nil   : null? nil = ;
: full? ( -- f ) pair-brk @ pair-count >= ;
: reserve   full? if gc then ;

: pair-rel ( n -- p )
  pairs pair-base @ + ;
: pair-allot ( -- p )
  pair-brk @ pair-rel 1 pair-brk +! ;

: pair ( x y -- p )
  reserve pair-allot
  dup dup >r >r cdr! r> car! r> ;
: cons pair ;
: unpair ( p -- x y ) dup car swap cdr ;

variable roots   nil roots !
: +root ( a -- ) roots @ pair roots ! ;
: root value lastxt >body +root ;

nil root foo
my-list to foo

variable broken-heart
: relocate ( a -- )
  dup @ unpair pair over @
  broken-heart over car! over swap cdr! swap ! ;
: conserve ( a -- )
  dup @ car broken-heart =
  if dup @ cdr swap ! else relocate then ;
: preserve ( a -- )
  dup @ old? if conserve else drop then ;
: newfixup1 ( n -- )
  dup pair-rel dup preserve cell+ preserve 1+ ;
: newfixup 0 begin dup pair-brk @ <
    while newfixup1 repeat drop ;

: rpwalk rp@ rp0 @ swap - cell / 0
  ?do rp@ i cells + preserve loop ;
: spwalk depth 0 ?do sp@ i cells + preserve loop ;
: rootwalk roots preserve roots @ ['] preserve foreach ;

: newspace
  0 pair-brk !
  pair-base @ pair-heap = if
    pair-heap pair-count pairs +
  else
    pair-heap
  then pair-base ! ;

: collect
  newspace
  rpwalk
  spwalk
  rootwalk
  newfixup
  full? if abort" heap full" then ;
' collect is gc   : used pair-brk @ ;

Parsing
  and
Printing

: l. recursive dup pair? if
    ." ( " ['] l. foreach'
    dup null? if drop else ." . " l. then
    ." ) "
  else
    dup null? if ." nil " else . then
  then ;

: list1 ( .. b n -- p )
  0 ?do pair loop ;
: list ( .. n -- p )
  nil swap list1 ;

9 8 7   3 list l.
( 9 8 7 )

variable list-depth
variable is-dotted
: ?dot ( pxn n )
  is-dotted @ 0= if nil swap else 1- then ;
: ((   list-depth @ is-dotted @ 0 is-dotted !
       depth list-depth ! ;
: ))   depth list-depth @ - ?dot list1 >r
       is-dotted ! list-depth ! r> ;
: ..   -1 is-dotted ! ;

(( 1 2 3 .. 4 )) l.
  ðŸ™œ
( 1 2 3 . 4 )

(( (( 1 1 )) (( 2 4 )) (( 3 9 )) )) l.
  ðŸ™œ
( ( 1 1 ) ( 2 4 ) ( 3 9 ) )

Lambdas / Closures
        ðŸ™œ
 â€¢ Bind arguments to procedures
 â€¢ CREATE DOES> but dynamic

: multiplier ( n -- )
  create , does> @ * ;
3 multiplier thrice
4 thrice .
  ðŸ™œ
7

: bind ( a xt -- p ) pair ;
: invoke ( p/a -- )
  begin dup pair? while
    unpair repeat execute ;

: multiplier ( n -- p )
  ['] * bind ;
4 3 multiplier invoke .
  ðŸ™œ
7

a b c ' foo bind bind bind

: foreach' ( l op -- last )
  begin over pair? while
    dup >r >r unpair r> swap >r
    invoke r> r> repeat drop ;
: foreach ( l op -- )
  foreach' null? 0= throw ;

: sum ( l -- n )
  0 swap ['] + foreach ;

(( 1 2 3 )) sum .
  ðŸ™œ
6

: chain1 ( a b -- )
  >r invoke r> invoke ;
: chain ( a b -- p )
  ['] chain1 bind bind ;

99 ' 1+ ' square chain invoke
  ðŸ™œ
10000

99  2 ' * bind  1 ' + bind  chain invoke .
  ðŸ™œ
199

: length ( l -- n )
  0 swap ['] drop ['] 1+ chain foreach ;
: average ( l -- n )
  dup sum swap length / ;

(( 1 2 3 )) length .
  ðŸ™œ
3

(( 1 2 3 )) average .
  ðŸ™œ
2

: ^pair swap pair ;
: reverse-append ( a b -- l )
  swap ['] ^pair foreach ;
: reverse ( l -- l' )
  nil reverse-append ;

(( 1 2 3 4 )) reverse l.
  ðŸ™œ
( 4 3 2 1 )

: append ( a b -- l )
  >r reverse r> reverse-append ;

(( 1 2 3 )) (( 4 5 6 )) append l.
  ðŸ™œ
( 1 2 3 4 5 6 )

: nilpair nil nil pair ;
: prepend! ( a p -- )
  dup >r car pair r> car! ;
: map1 ( a op p -- )
  >r invoke r> prepend! ;
: map ( l op -- l' )
  nilpair dup >r ['] map1 bind bind
  foreach r> car reverse ;

(( 1 2 3 4 5 )) ' square map l.
  ðŸ™œ
( 1 4 9 16 25 )

: range ( a b -- p )
  1- nil -rot ?do i ^pair -1 +loop ;

0 10 range l.
  ðŸ™œ
( 0 1 2 3 4 5 6 7 8 9 )

: filter1 ( a op p -- )
  >r over >r invoke r> r> rot
  if prepend! else 2drop then ;
: filter ( l op -- l' )
  nilpair dup >r ['] filter1 bind bind
  foreach r> car reverse ;

2 100 range ' prime? filter l.
  ðŸ™œ
( 2 3 5 7 11 13 17 19 23 29 31
  37 41 43 47 53 59 61 67 71 73
  79 83 89 97 )

: l= ( a b -- f ) recursive dup pair? if
    2dup car swap car l=
    >r cdr swap cdr l= r> and
  else
     =
  then ;

CAVEATS
   ðŸ™¤
 â€¢ Numbers in range of heap _unstable_
   â€¢ Fix with boxing in a pair or tagged integers
   â€¢ No hooks for resource freeing
 â€¢ Non-pairs, not freed
 â€¢ Concurrency & Performance

   What's up
with the slides?

PRESENTATION FORMAT
         ðŸ™¤
 â€¢ Takahashi Method
   â€¢ Minimalistic presentation style
   â€¢ suckless â†’  sent â†’  websent
   â€¢ 200 LOC
 â€¢ Focus on content
   â€¢ Unicode text file as input
   â€¢ Show each paragraph fullscreen
   â€¢ @image.png for full page images

@stenoforth.png
<img src="stenoforth.png">

trees
ðŸŒ²ðŸŒ²ðŸŒ²ðŸŒ²
 
evil
ðŸ™ˆðŸ™‰ðŸ™Š
 
â™¤ spades
â™¥ hearts
â™§ clubs
â™¦ diamonds

trees
ðŸŒ²ðŸŒ²ðŸŒ²ðŸŒ²

evil
ðŸ™ˆðŸ™‰ðŸ™Š

â™¤ spades
â™¥ hearts
â™§ clubs
â™¦ diamonds

QUESTIONS?
    âš˜
thank you!
