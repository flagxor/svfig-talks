<!DOCTYPE html>
<script src="../websent/websent.js"></script><script>
FONT = 'Courier';
USABLE = 0.9;
BACKGROUND = '#047';
FOREGROUND = '#fc0';
</script><pre>

     Lisp-y
Data Abstraction
    in Forth
       ðŸ™œ
   Brad Nelson
       ðŸ™œ
December 19, 2020

Introduction
     ðŸ™œ
 â€¢ Lisp's pair data structure is composable
 â€¢ When combined with lambda expressions


(car (cons x y)) = x
(cdr (cons x y)) = y

(cons 1 2)
    =
  ( 1 . 2 )

(cons 1 (cons 2 (cons 3 nil)))
             =
          ( 1 2 3 )

((1 1) (2 4) (3 9) (4 16))

+---+---+
| 1 | o |
+---+-|-+
      v
    +---+---+
    | 2 | o |
    +---+-|-+
          v
        +---+---+
        | 3 |NIL|
        +---+---+

( x y )  pair  ( p )
  ( p ) unpair ( x y )

1000000 constant pair-count   : pairs ( n -- n ) 2* cells ;
pair-count pairs 2* allocate throw constant pair-heap
variable pair-brk   variable pair-base   pair-heap pair-base !

: pair+? ( p -- f ) pair-heap - dup 0>= swap pair-count pairs 2* < and ;
: pair? ( p -- f ) pair-base @ - dup 0>= swap pair-count pairs < and ;
: old? ( p -- f) dup pair+? swap pair? 0= and ;
: car ( p -- n ) @ ;    : cdr ( p -- n ) cell+ @ ;
: car! ( n p -- ) ! ;   : cdr! ( n p -- ) cell+ ! ;

defer gc   create nil
: full? ( -- f ) pair-brk @ pair-count >= ;
: reserve   full? if gc then ;
: pair-rel ( n -- p ) pairs pair-base @ + ;
: pair-allot ( -- p ) pair-brk @ pair-rel 1 pair-brk +! ;
: pair ( x y -- p ) reserve pair-allot dup dup >r >r cdr! r> car! r> ;
: unpair ( p -- x y ) dup car swap cdr ;   : cons pair ;

: bind ( a xt -- p ) pair ;
: bind' ( a -- p ) ' bind ;
: bind['] ( a -- p ) ' postpone bind ; immediate
: invoke ( p/a -- ) begin dup pair? while unpair repeat execute ;

: foreach' ( l op -- last )
  begin over pair? while dup >r >r unpair r> swap >r invoke r> r> repeat drop ;
: foreach ( l op -- ) foreach' nil <> throw ;

: ^pair swap pair ;
: reverse-append ( a b -- l ) swap ['] ^pair foreach ;
: reverse ( l -- l' ) nil reverse-append ;
: append ( a b -- l ) >r reverse r> reverse-append ;

: nilpair nil nil pair ;
: prepend! ( a p -- ) dup >r car pair r> car! ;
: map1 ( a op p -- ) >r invoke r> prepend! ;
: map ( l op -- l' ) nilpair dup >r ['] map1 bind bind foreach r> car reverse ;
: filter1 ( a op p -- )
  >r over >r invoke r> r> rot if prepend! else 2drop then ;
: filter ( l op -- l' )
  nilpair dup >r ['] filter1 bind bind foreach r> car reverse ;
: range ( a b -- p ) 1- nil -rot ?do i ^pair -1 +loop ;

variable roots   nil roots !
: +root ( a -- ) roots @ pair roots ! ;
: root create here nil , +root ;

variable broken-heart
: relocate ( a -- )
  dup @ unpair pair over @ broken-heart over car! over swap cdr! swap ! ;
: conserve ( a -- )
  dup @ car broken-heart = if dup @ cdr swap ! else relocate then ;
: preserve ( a -- ) dup @ old? if conserve else drop then ;
: newfixup1 ( n -- ) dup pair-rel dup preserve cell+ preserve 1+ ;
: newfixup 0 begin dup pair-brk @ < while newfixup1 repeat drop ;

: rpwalk rp@ rp0 @ swap - cell / 0 ?do rp@ i cells + preserve loop ;
: spwalk depth 0 ?do sp@ i cells + preserve loop ;
: rootwalk roots preserve roots @ ['] preserve foreach ;
: newspace   0 pair-brk !   pair-base @ pair-heap =
  if pair-heap pair-count pairs + else pair-heap then pair-base ! ;
: collect   newspace rpwalk spwalk rootwalk newfixup
            full? if abort" heap full" then ;
' collect is gc   : used pair-brk @ ;

: list' ( .. b n -- p ) 0 ?do pair loop ;
: list ( .. n -- p ) nil swap list' ;
variable list-depth   variable is-dotted
: ?dot ( pxn n ) is-dotted @ 0= if nil swap else 1- then ;
: ((   list-depth @ is-dotted @ 0 is-dotted ! depth list-depth ! ;
: ))   depth list-depth @ - ?dot list' >r is-dotted ! list-depth ! r> ;
: ..   -1 is-dotted ! ;
: l. recursive dup pair? if
  ." ( " ['] l. foreach' dup nil = if drop else ." . " l. then ." ) " else . then ;

( --------------------- )

: sample (( 1 2 3 4 5 6 7 8 9 )) ;
: square dup * ;
: sum 0 swap ['] + foreach ;
: prime?
  dup 2 < if drop 0 exit then
  dup 2 ?do dup i mod 0= if unloop drop 0 exit then loop ;
: digits ( n -- l ) nil swap begin base @ /mod >r ^pair r> dup 0= until drop ;
: l= ( a b -- f ) recursive dup pair? if 2dup car swap car l= >r cdr swap cdr l= r> and else = then ;

: palindrome? ( n -- f ) digits dup reverse l= ;
: palindromes 0 100000 range ['] palindrome? filter l. ;

: test sample sample append dup append dup ['] square map append dup l. sum . ;

   What's up
with the slides?

PRESENTATION FORMAT
         ðŸ™¤
 â€¢ Takahashi Method
   â€¢ Minimalistic presentation style
   â€¢ suckless â†’  sent â†’  websent
   â€¢ 200 LOC
 â€¢ Focus on content
   â€¢ Unicode text file as input
   â€¢ Show each paragraph fullscreen
   â€¢ @image.png for full page images

@stenoforth.png
<img src="stenoforth.png">

trees
ðŸŒ²ðŸŒ²ðŸŒ²ðŸŒ²

evil
ðŸ™ˆðŸ™‰ðŸ™Š

â™¤ spades
â™¥ hearts
â™§ clubs
â™¦ diamonds

trees
ðŸŒ²ðŸŒ²ðŸŒ²ðŸŒ²

evil
ðŸ™ˆðŸ™‰ðŸ™Š

â™¤ spades
â™¥ hearts
â™§ clubs
â™¦ diamonds

QUESTIONS?
    âš˜
thank you!
