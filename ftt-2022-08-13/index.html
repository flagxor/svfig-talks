<!DOCTYPE html>
<script src="../websent/websent.js"></script><script>
FONT = 'Courier';
USABLE = 0.9;
LINE_SPACING = 1.2;
BACKGROUND = '#ffa';
FOREGROUND = '#111';
</script><pre>

ğŸ™¬ ESP32forth Sockets ğŸ™®
       ğŸ™š     ğŸ™˜
    August 13, 2022

ğŸ™¬ Berkeley Sockets ğŸ™®
 
â€¢ THE Internet Networking API
â€¢ Released in 1983, free of AT&T in 1989
â€¢ File descriptors as network endpoints
â€¢ Multi-protocol and Multi-transport
â€¢ Designed to support concurrency

ğŸ™¬ Multi-Transport ğŸ™®
 
AF_INET  - IPv4
AF_INET6 - IPv6
AF_UNIX  - domain socket

ğŸ™¬ IPv4 & IPv6 ğŸ™®
  
IPv4 192.168.0.1
IPv6 2001:0db8:85a3:0000:0000:8a2e:0370:7334
     2001:db8:85a3:::8a2e:370:7334

ğŸ™¬ Multi-Protocol ğŸ™®
 
SOCK_STREAM - TCP
SOCK_DGRAM  - UDP

ğŸ™¬ TCP ğŸ™®
 
â€¢ Transmission Control Protocol
â€¢ Bi-directional byte stream
â€¢ Connection oriented
  â€¢ Multiple inbound connections
â€¢ Reliable delivery
â€¢ Auto-adapts to network conditions

ğŸ™¬ TCP Use-cases ğŸ™®
 
â€¢ HTTP / HTTPS
â€¢ SSH
â€¢ Telnet
â€¢ FTP

ğŸ™¬ UDP ğŸ™®
 
â€¢ User Datagram Protocol
â€¢ Variable length packets
  â€¢ Up to 65,527 bytes
  â€¢ About ~500 bytes practical
â€¢ Connectionless
â€¢ Unreliabled, packets can be:
  â€¢ lost
  â€¢ corrupt
  â€¢ repeated
  â€¢ out of order

ğŸ™¬ UDP Use-cases ğŸ™®
 
â€¢ DNS
â€¢ DHCP
â€¢ Video/Audio streaming

ğŸ™¬ struct sockaddr_in ğŸ™®
 
[    ][    ][    ][    ]
------------------------
[  family  ][   port   ]
------------------------
[       address        ]
------------------------

ğŸ™¬ struct sockaddr_in ğŸ™®
 
[    ][    ][    ][    ][    ][    ][    ][    ]
------------------------------------------------
[  family  ][   port   ][       flow info      ]
------------------------------------------------
[                   address                    ]
------------------------------------------------
[       scope id       ]
------------------------

ğŸ™¬ Big-Endian ğŸ™®
  
ntohs htons
ntohl htonl

ğŸ™¬ Making a TCP Connection ğŸ™®
   
gethostbyname(hostname)
socket(domain, type, protocol)
connect(sock, addr, addrlen)
send(sock, data, datalen, flags)     
recv(sock, data, datalen, flags)
close(sock)

ğŸ™¬ Making a TCP Connection ğŸ™®
   
gethostbyname - lookup DNS
socket        - make a socket
connect       - connect to an address
send          - send data
recv          - receive data
close         - close connection

ğŸ™¬ Looking up a Host ğŸ™®
 
struct hostent {
    char  *h_name;            /* official name of host */
    char **h_aliases;         /* alias list */
    int    h_addrtype;        /* host address type */
    int    h_length;          /* length of address */
    char **h_addr_list;       /* list of addresses */
}
#define h_addr h_addr_list[0] /* for backward compatibility */

( Lookup a Host ) 
z" google.com" gethostbyname constant google.com
google.com ->h_addr ip.
142.251.46.238 ok
 
( Fill in an address + port )
sockaddr googleaddr
80 googleaddr ->port!
google.com ->h_addr googleaddr ->addr!
 
( Create a socket and connect )
AF_INET SOCK_STREAM 0 socket value sock
sock googleaddr sizeof(sockaddr_in) connect throw

( Send an HTTP request )
s" GET / HTTP/1.0" sock write-file throw
: semit ( ch s -- ) swap >r rp@ swap 1 swap write-file throw rdrop ;
: semit ( ch s -- ) swap >r rp@ 1 0 send 0< throw rdrop ;
: scr   13 sock semit 10 sock semit ;
scr scr
   
( Read and print part of reply )
here 100000 sock read-file throw constant len
here len type

ğŸ™¬ A TCP Server ğŸ™®
   
socket(domain, type, protocol)
bind(sock, addr, addrlen)
listen(sock, backlog)
accept(sock, addr, *addrlen)
send(sock, data, datalen, flags)          
recv(sock, data, datalen, flags)
close(sock)

ğŸ™¬ A TCP Server ğŸ™®
   
socket  - make a socket
bind    - bind it to a port
listen  - listen for up to n connections
accept  - accept a connection (new socket)
send    - send data
recv    - receive data
close   - close the connection

ğŸ™¬ Server Challenges ğŸ™®
    
â€¢ Management multiple connections
â€¢ Blocking on connections
â€¢ poll / select
  â€¢ fd_set etc. absent

ğŸ™¬ A UDP Client/Server ğŸ™®
  
gethostbyname(hostname)
socket(domain, type, protocol)
bind(sock, addr, addrlen)
sendto(sock, data, datalen, flags, addr, addrlen)
recvfrom(sock, data, datalen, flags, addr, *addrlen)
close(sock)

ğŸ™¬ A UDP Client/Server ğŸ™®
  
gethostbyname - lookup other hosts
socket        - make a socket
bind          - bind it to an incoming port         
sendto        - send a packet
recvfrom      - receive a packet
close         - close the binding

( Create a addres to listen on )
sockaddr incoming
9999 incoming ->port!
 
( Create a socket and bind to address )
AF_INET SOCK_DGRAM 0 socket value sockfd
sockfd non-block throw  ( Optionally make non-blocking )
sockfd incoming sizeof(sockaddr_in) bind throw

( Read an incoming packet )
sockaddr received
variable received-len sizeof(sockaddr_in) received-len !
sockfd msg len 0 received received-len recvfrom to len
received ->addr@ ip. ." :" received ->port@ . 
    space space msg swap type cr

( Send an outgoing packet )
sockaddr outgoing
: say ( port -- "host" )
  ( Setup address )
  outgoing ->port!
  bl parse s>z gethostbyname ->h_addr outgoing ->addr!
  ( Sent rest of the parse buffer as the message )
  sockfd tib >in @ + #tib @ >in @ -
    0 outgoing sizeof(sockaddr_in) sendto drop
  #tib @ >in !
;

ğŸ™¬ Visual Editor (BONUS) ğŸ™®
  
â€¢ visual edit /spiffs/filename
â€¢ Arrows / PgUp / PgDn
â€¢ Ctrl-S to save
â€¢ Ctrl-X to exit
â€¢ Very wasteful, WIP

DEMO & QUESTIONS?
       ğŸµ
   Thank you!
