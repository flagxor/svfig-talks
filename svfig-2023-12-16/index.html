<!DOCTYPE html>
<script src="../websent/websent.js"></script><script>
FONT = 'consolas; courier';
USABLE = 0.9;
LINE_SPACING = 1.2;
BACKGROUND = '#000044';
FOREGROUND = '#ffff00';
</script><pre>

ÂµEforth on the pico-ice
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   December 16, 2023

ğŸ         ğŸ§Š          ğŸ
    On Forth Day 2023
   Christopher Lozinski
ğŸ§Š  generously gifted   ğŸ§Š
      me a pico-ice!
ğŸ         ğŸ§Š          ğŸ

pico-ice
â•â•â•â•â•â•â•â•
â€¢ Raspberry Pi Pico (RP2040) + iCE40UP5K FPGA
â€¢ 4MB SPI Flash for CPU
â€¢ 4MB SPI Flash for FPGA
â€¢ 8MB low power qSPI RAM
â€¢ Shared RGB LED
â€¢ All RP2040 + iCE40 pins exposed
â€¢ 2 pushbuttons (one mostly for reset)
â€¢ FPGA clock controlled by RP2040
â€¢ RP2040 can feed configuration to FPGA!

RP2040
â•â•â•â•â•â•
â€¢ 133 MHz dual ARM Cortex-M0+
â€¢ 264K SRAM
â€¢ 30 GPIO pins (4 can be analog)
â€¢ 2 UARTs
â€¢ 2 SPI controllers
â€¢ 2 IÂ²C controllers
â€¢ 16 PWM channels
â€¢ USB 1.1 controller and PHY,
  with host and device support
â€¢ 8 programmed inputâ€“output (PIO)
  state machines
â€¢ Boots over SPI or USB

PIO
â•â•â•
â€¢ 2 x Versatile programmable I/O blocks
  - 4 Shift registers + state machines each
â€¢ Hardware can handle:
  - 8080 and 6800 parallel bus
  - I2C, 3-pin I2S
  - SDIO
  - SPI, DSPI, QSPI
  - UART
  - DVI or VGA (via resistor DAC)

@pio_layout.png
<img src="pio_layout.png">

PIO Model
â•â•â•â•â•â•â•â•â•
â€¢ Two 32-bit shift registers â€“ either direction, any shift count
â€¢ Two 32-bit scratch registers
â€¢ 4Ã—32-bit bus FIFO in each direction (TX/RX),
  reconfigurable as 8Ã—32 in a single direction
â€¢ Fractional clock divider (16 integer, 8 fractional bits)
â€¢ Flexible GPIO mapping (all 30 pins)
â€¢ DMA interface, sustained throughput
  up to 1 word per clock from system DMA
â€¢ IRQ flag set/clear/status

@pio_model.png
<img src="pio_model.png">

@pio_square.png
<img src="pio_square.png">

@pio_instr.png
<img src="pio_instr.png">

iCE40UP5K
â•â•â•â•â•â•â•â•â•
â€¢ 5280 LUTs
â€¢ 1Mbit single port RAM
â€¢ 120Kb dual port RAM
â€¢ 8 x DSP blocks

@ice40-top.png
<img src="ice40-top.png">

sysDSP
â•â•â•â•â•â•
â€¢ 8-bit x 8-bit Multiplier
â€¢ 16-bit x 16-bit Multiplier
â€¢ 16-bit Adder/Subtracter
â€¢ 32-bit Adder/Subtracter
â€¢ 16-bit Accumulator
â€¢ 32-bit Accumulator
â€¢ 8-bit x 8-bit Multiply-Accumulate
â€¢ 16-bit x 16-bit Multiply-Accumulate

@ice40-dsp.png
<img src="ice40-dsp.png">

@ice40-io.png
<img src="ice40-io.png">

@ice40-dpram.png
<img src="ice40-dpram.png">

@ice40-spram.png
<img src="ice40-spram.png">

Programming the pico-ice
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â€¢ pico-sdk
â€¢ pico-ice-sdk
â€¢ Transfer via Flash drive + UF2
â€¢ I/O over one or more
  virtual serial devices

UF2
â•â•â•
â€¢ UF2 = USB Flashing Format
â€¢ Created by Microsoft for MakeCode
â€¢ 512 Blocks to align with FAT Flash drive blocks
â€¢ Whole blocks arrive or not
â€¢ Each block has:
  - magic numbers at the beginning and at the end
  - address where the data should be flashed
  - up to 476 bytes of data

ÂµEforth
â•â•â•â•â•â•â•
â€¢ Indirect-threaded Forth
â€¢ Written in C
â€¢ Extensive use of X-Macros
â€¢ Ports to:
  - ESP32 (Known as ESP32forth)
  - Linux/Posix
  - Windows
  - Web (via Asm.js)
  - pico-ice?

X-MACROS
â•â•â•â•â•â•â•â•
 â€¢ Use the C Preprocessor
 â€¢ Lists of data to build code
 â€¢ Make the caller a parameter

 #define PRIMITIVE_LIST \
   X("+", ADD, tos += *sp; --sp) \
   Y(DROP, tos = *sp; --sp) \
   Y(SWAP, w = tos; tos = *sp; *sp = w) \
   Y(AND, tos = tos & *sp; --sp) \
   Y(OR, tos = tos | *sp; --sp) \

 enum {
 #define X(sname, name, code) OP_ ## name,
 PRIMITIVE_LIST
 #undef X
 };

Porting ÂµEforth
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â€¢ git submodules for SDKs
â€¢ Add CMake build invoked by Make
â€¢ Leave out fault handling to start
â€¢ New builtins.h + main.cpp
â€¢ And... it didn't run...

Debugging
â•â•â•â•â•â•â•â•â•
â€¢ Confirmed basic IO samples work
â€¢ Added a "sim" variant like ESP32
â€¢ Found failures in the startup before IO ready
â€¢ And... it came up!

Bindings
â•â•â•â•â•â•â•â•
â€¢ memory support
â€¢ yield + ms-ticks support
â€¢ general posix files
â€¢ ice
  - ice_cram_*
  - ice_flash_*
  - ice_fpga_*
  - ice_led_*
  - ice_spi_*
  - ice_sram_*
â€¢ pico
  - adc_*
  - TODO: MORE!

Making it Faster
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â€¢ Shallow submodules
â€¢ Init only the needed modules
â€¢ Build only your target!
â€¢ cmake -G Ninja

Publishing
â•â•â•â•â•â•â•â•â•â•
â€¢ Some refactoring of documentation
â€¢ For now don't publish by default
â€¢ Beta only for now

What's Next?
â•â•â•â•â•â•â•â•â•â•â•â•
â€¢ Expose more USB bindings
â€¢ Expose more hardware bindings
â€¢ Add BLOCKs + use FPGA Flash for it
â€¢ Figure out how to build directly/faster?
  - Arduino tools build instead?
â€¢ Synthesize for the FPGA in Forth!

icestorm/YoSYS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â€¢ Community has reverse engineered
  the iCE40 bitstream format!
â€¢ Built an open source verilog
â€¢ icepack capture fairly simple config layout

@ice40-plb.png
<img src="ice40-plb.png">

@ice40-viewer.png
<img src="ice40-viewer.png">

https://knielsen.github.io/ice40_viewer/ice40_viewer.html

iCE40 Format
â•â•â•â•â•â•â•â•â•â•â•â•
â€¢ icepack capture fairly simple config layout:
    if (right_half)
      cram_x = bank_xoff + column_width - 1 - bit_x;
    else
      cram_x = bank_xoff + bit_x;
    if (top_half)
      cram_y = bank_yoff + (15 - bit_y);
    else
      cram_y = bank_yoff + bit_y;

.logic_tile_bitmap
Nobrrrr-rrrrrrbbbbbb-bbbbbbbbbbbbbbbllllllllllbbb--bbb
--orrrr-rrrrrrbbbbbb-bbbbbbbbbbbbbbbllllllllllbbbbCbbb
bbbrrrr-rrrrrrbbbbbb-bbbbbbbbbbbbbbbllllllllllbbb-bbbb
bbbrrrr-rrrrrrbbbbbb-bbbbbbbbbbbbbbbllllllllllbbb--bbb
bbbrrrr-rrrrrrbbbbbb-bbbbbbbbbbbbbbbllllllllllbbb-bbbb
bborrrr-rrrrrrbbbbbb-bbbbbbbbbbbbbbbllllllllllbbb--bbb
bbbrrrr-rrrrrrbbbbbb-bbbbbbbbbbbbbbbllllllllllbbb-bbbb
bborrrr-rrrrrrbbbbbb-bbbbbbbbbbbbbbbllllllllllbbb--bbb
bbbrrrr-rrrrrrbbbbbb-bbbbbbbbbbbbbbbllllllllllbbb-bbbb
bborrrr-rrrrrrbbbbbb-bbbbbbbbbbbbbbbllllllllllbbb--bbb
bbbrrrr-rrrrrrbbbbbb-bbbbbbbbbbbbbbbllllllllllbbb-bbbb
bborrrr-rrrrrrbbbbbb-bbbbbbbbbbbbbbbllllllllllbbb--bbb
bbbrrrr-rrrrrrbbbbbb-bbbbbbbbbbbbbbbllllllllllbbb-bbbb
bborrrr-rrrrrrbbbbbb-bbbbbbbbbbbbbbbllllllllllbbb--bbb
bbbrrrr-rrrrrrbbbbbb-bbbbbbbbbbbbbbbllllllllllbbb-bbbb
bborrrr-rrrrrrbbbbbb-bbbbbbbbbbbbbbbllllllllllbbb--bbb
- ... unknown bit
r ... routing
b ... buffer
l ... logic bits
o ... ColBufCtrl
C ... CarryInSet
N ... NegClk

@ice40-spans.png
<img src="ice40-spans.png">

Plan for Synthesis
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â€¢ Keep an allocation map for LUTs + Routes
â€¢ Reserve LUTs + routes greedily,
  provide manual words to move allocation point
â€¢ Group signal in link list "bus" value

BUS ( bool-wire bus -- bus )
UNBUS ( bus -- bool-wire bus )
2LUT ( a b T -- v )
AT ( x y -- )

: AND ( a b -- v ) $8 2LUT ;
: OR ( a b -- v ) $E 2LUT ;
: XOR ( a b -- v ) $9 2LUT ;

: HA ( a b -- s c ) 2DUP AND >R XOR R> ;
: FA ( a b c -- s c ) HA >R HA R> OR ;

: ADDER ( cin a b n -- s cout )
   NEWBUS
   SWAP 0 DO
      >R UNBUS >R SWAP UNBUS >R FA
      SWAP R> SWAP R> SWAP R> BUS
   LOOP
   NIP NIP SWAP
;

1 IN PIN go
1 OUT PIN result
8 BIT REGISTER counter
go counter counter ADDER ON-CLOCK counter
counter UNBUS DROP ALWAYS result

DEMO

QUESTIONSâ“
    ğŸ™
 Thank you!
