<!DOCTYPE html>
<script src="../websent/websent.js"></script><script>
FONT = 'Consolas, monospace';
USABLE = 0.9;
LINE_SPACING = 1.2;
BACKGROUND = '#224';
FOREGROUND = '#ffd';
</script><pre>

Forth Synergy
   ðŸ§ðŸ§ðŸ§ðŸ§
     ðŸ™œ
July 24, 2021

FORTH ðŸº
the LONE WOLF

FORTH IS POWERFUL
  ðŸ—²
â€¢ Compile Time Metaprogramming
â€¢ Domain Specific Languages

FORTH IS SUCCINCT
  ðŸž
: WASHER
   WASH SPIN RINSE SPIN ;

But FORTH can be CRYPTIC!
      ðŸ”®
: ch>stream ( ch st -- )
   dup wait-write
   >r r@ >write @ r@ >offset c!
   r@ >write @ 1+ r@ @ mod r> >write ! ;

How can we program
        ðŸ‘ª
 Forth together?

Do we ðŸ‘¹
 want to?

More Hands aren't
   Always Good!
ðŸ–®ðŸ’ ðŸ–®ðŸ’ ðŸ–®ðŸ’ ðŸ–®ðŸ’
ðŸ–®ðŸ’ ðŸ–®ðŸ’ ðŸ–®ðŸ’ ðŸ–®ðŸ’
ðŸ–®ðŸ’ ðŸ–®ðŸ’ ðŸ–®ðŸ’ ðŸ–®ðŸ’
ðŸ–®ðŸ’ ðŸ–®ðŸ’ ðŸ–®ðŸ’ ðŸ–®ðŸ’

WHY THEN?      ðŸ‘ðŸ‘ðŸ‘ðŸ‘
   ðŸ™¤
â€¢ Sometimes you're programming
  with YOURSELF from years ago
â€¢ We use words because
  we hope to connect!
â€¢ Help Forth play in a complex world

FOCUS ON TWO GAPS
   ðŸ™¤
â€¢ Modularity ðŸ”Œ
â€¢ Data Abstraction

MODULARITY ðŸ”Œ
    ðŸ™¤
â€¢ Be explicit about interfaces
â€¢ Limit how much has to be
  understood at once
â€¢ Limit the effects of change

THINKING FORTH ðŸ“˜:
      ðŸ™¤
"But Forth extends the concepts of modularity
 and information-hiding further than any other
 contemporary language. Forth even hides
 the manner in which words are invoked and
 the way local arguments are passed."

How to make
     ðŸ”Œ
 a Module?

FORML ðŸ‘¨â€âš–ï¸ - Dewey Val Schorre
             ðŸ™¤
: INTERNAL ( --> ADDR) CURRENT @ @ ;
: EXTERNAL ( --> ADDR) HERE ;
: MODULE( ADDRl ADDR2 --> )PFA LFA ! ;
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
https://www.complang.tuwien.ac.at
  /forth/forth-dimensions/FD-V2.pdf

INTERNAL                       ðŸ‘¨â€âš–ï¸
  100 constant stack-depth
  create elements stack-depth cells allot
  variable tos  elements tos !
EXTERNAL
  : >p ( n -- ) cell tos +! tos @ ! ;
  : p@ ( -- n ) tos @ @ ;
  : p> ( -- n ) p@ -1 cells tos +! ;
MODULE

GET-CURRENT VOCABULARY Stack ALSO Stack DEFINITIONS
  100 constant stack-depth
  create elements stack-depth cells allot
  variable tos  elements tos !
SET-CURRENT
  : >p ( n -- ) cell tos +! tos @ ! ;
  : p@ ( -- n ) tos @ @ ;
  : p> ( -- n ) p@ -1 cells tos +! ;
PREVIOUS                                          ðŸ—«
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
https://www.complang.tuwien.ac.at/forth/gforth
  /Docs-html/Word-list-example.html#Word-list-example

PROBLEMS ðŸ‘Ž ðŸ¤¢
   ðŸ™¤
â€¢ Internals can't call externals
â€¢ Externals are shared with everyone

( What if this is INTERNAL? ðŸ¤¢ )
: pover   p> p> dup >r >p >p r> ;
( But this is EXTERNAL ðŸ˜²)
: 2pdup   pover pover ;

GET-CURRENT VOCABULARY Stack ALSO Stack DEFINITIONS
  100 constant stack-depth
  create elements stack-depth cells allot
  variable tos  elements tos !
  : >p ( n -- ) cell tos +! tos @ ! ; ðŸ˜•
  : pover   p> p> dup >r >p >p r> ; ðŸ˜•
SET-CURRENT
  : 2pdup   pover pover ;  ðŸ˜•
  : >p   >p ;  ðŸ˜•
  : p@ ( -- n ) tos @ @ ;
  : p> ( -- n ) p@ -1 cells tos +! ;
PREVIOUS

+----------+
| stack.fs |<----+
+----------+     |
  ^              |
  |              |
+-+------+   +---+----+
| foo.fs |-->| bar.fs |
+--------+   +--------+
       ^      ^
       |      |
     +-+------++
     | main.fs |
     +---------+

N+1th MODULE SYSTEM âž•âž•
   ðŸ™¤
â€¢ Python like import syntax
â€¢ Explicit out of order exports
â€¢ Two wordlists per module
â€¢ Share instances of an import

modules.fs  ðŸ”Œ
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
wordlist constant modules
variable exporting
: >wordlist ( xt wid -- )
   get-current >r set-current execute r> set-current ;
: import-name ( a n -- )
   2dup included? 0= if
     2>r exporting @ wordlist exporting ! ( new exports )
     2r> 2dup 2>r nextname exporting @ ['] constant modules >wordlist
     get-current get-order ( save search order )
     only forth wordlist >order definitions ( new wordlist )
     2r> 2dup 2>r included
     set-order set-current ( restore search order )
     exporting ! ( restore exports ) 2r>
   then
   modules search-wordlist 0= throw execute >order ;
: import ( "module" ) bl parse import-name ;
: alias-last   latest name>string nextname lastxt alias ;
: export   ['] alias-last exporting @ >wordlist ;

collections/stack.fs  ðŸ“š
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
100 constant stack-depth
create elements stack-depth cells allot
variable tos  elements tos !
: >p ( n -- ) cell tos +! tos @ ! ; EXPORT
: p@ ( -- n ) tos @ @ ; EXPORT
: p> ( -- n ) p@ -1 cells tos +! ; EXPORT

foo.fs  âœ¨
â€”â€”â€”â€”â€”â€”
import collections/stack.fs
import bar.fs
: run   1 >p 2 >p 3 >p 3p. ; EXPORT

bar.fs  ðŸ”¥
â€”â€”â€”â€”â€”â€”
import collections/stack.fs
: 3p.   p> p> p> . . . cr ; EXPORT

main.fs  ðŸ¦ž
â€”â€”â€”â€”â€”â€”â€”
needs modules.fs
import foo.fs
run bye

âš ï¸ ~ WARNING ~ âš ï¸
Uncertain Findings

ELEMENTS OF PROGRAMMING ðŸ§ª
   ðŸ™¤
â€¢ Primitive Expressions
  - the simplest entities
    the language is concerned with
â€¢ Means of Combination
  - how compound elements are built
    from simpler ones
â€¢ Means of Abstraction
  - how compound elements can be
    named and manipulated as units
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
https://mitpress.mit.edu/sites/default
  /files/sicp/full-text/sicp/book/node5.html

MEANS OF DATA COMBINATION ðŸ§ª
   ðŸ™¤
â€¢ In conventions languages structures and arrays
  - Structures are feasible in Forth, but unidiomatic
  - Arrays in Forth are untyped
â€¢ This is a weak spot in Forth's typical usage
  - You can easily define strings,
    but not so easily fuse 2 of them into
    a First+Last name "thing".
  - You can make a stack and a string,
    but this doesn't naturally create a stack of strings.

MEANS OF DATA ABSTRACTION ðŸ§ª
   ðŸ™¤
â€¢ CREATE DOES> is the closest mechanism in Forth
  - But it dispatches only a single operation.

OBJECT ORIENTED LEXICONS ðŸ§±
   ðŸ™¤
â€¢ SWOOP or other OO lexicons "solve" Forth's weak
  data combination and abstraction,
  but at the cost of a "C++/Java in Forth" style.
â€¢ OO puts data first, which usually requires naming
  that data. Forth wants data hidden/implicit:
  : WASHER
     WASH SPIN RINSE SPIN ;

CLASS POINT        âœ´ï¸
  VARIABLE X
  VARIABLE Y
  : SHOW ( -- )   X @ . Y @ . ;
  : DOT ( -- )   ." Point at " SHOW ;
END-CLASS
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
http://soton.mpeforth.com/flag/swoop/index.html

POINT BUILDS ORIGIN    âœ´ï¸
5 ORIGIN X !
8 ORIGIN Y !
ORIGIN DOT
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
http://soton.mpeforth.com/flag/swoop/index.html

0 VALUE FOO            \ Contains pointer to instance
POINT NEW TO FOO       \ Construct instance of class POINT
8 FOO USING POINT X !  \ Store data in X
99 FOO USING POINT Y ! \ Store data in Y
FOO USING POINT DOT    \ Display X and Y
FOO DESTROY  0 TO FOO  \ Release space     âœ´ï¸
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
http://soton.mpeforth.com/flag/swoop/index.html

DATA GENERALIZATION ðŸŽ–ï¸
   ðŸ™¤
â€¢ Naturalistic Forth relies on
  implict scope/context
â€¢ When data needs to generalize,
  this best happens by introducing
  abstraction of that context

APPROACHES TO GENERALIZATION ðŸŽ–ï¸
   ðŸ™¤
â€¢ Singleton - UPDATE, PAD
â€¢ Additional Stacks
  â€¢ Implicit Stack - String stack
  â€¢ Explicit Stack - Graphics Context
â€¢ Named - VOCABULARY, USE
â€¢ References - OPEN-FILE, ALLOCATE

IMPLICIT STACK ðŸ“š
   ðŸ™¤
$" foo" $" bar" $+ $.

EXPLICIT STACK ðŸ“š

: box ( n -- ) ðŸ¥¡
   4 0 do
     dup fd 90 rt
   loop drop ;

save-pen    ðŸ–Šï¸
  100 100 moveto
  10 box
  200 200 moveto
  10 box
restore-pen

NAMED ðŸ“›
  ðŸ™¤
screen 10 box
printer 10 box

REFERENCES ðŸ“™
  ðŸ™¤
â€¢ Passed around on stack
â€¢ Remeber to release it!

EASY TRANSITIONS ðŸ’º
   ðŸ™¤
Singleton â†’ Stack
Singleton â†’ Named

HARD TRANSITIONS ðŸ˜µ
   ðŸ™¤
Singleton â†’ References
  â€¢ Update all callers
  â€¢ Manage lifetime

How to avoid
     ðŸ“™
 References?

s" source.txt" R/O OPEN-FILE
READ-COMPLEX-DATA
CLOSE-FILE              ðŸ—„ï¸

s" source.txt" R/O OPEN-FILE infile
s" dest.txt" W/O OPEN-FILE outfile
infile READ-COMPLEX-DATA
outfile WRITE-COMPLEX-DATA
infile CLOSE-FILE
outfile CLOSE-FILE             ðŸ“‚

s" source.txt" R/O OPEN-FILE
  s" dest.txt" W/O OPEN-FILE
    READ-COMPLEX-DATA FILE-SWAP
    WRITE-COMPLEX-DATA
  CLOSE-FILE
CLOSE-FILE                ðŸ—ƒï¸

What about
    ðŸ¦
 Generics?

"PARTS"  âš™ï¸
   ðŸ™¤
â€¢ Create a scope/context
  bearing thing
â€¢ Use variables defined
  relative to a context
â€¢ Capture enough info to
  allocate multiple instances

variable @part  âš™ï¸
: part ( "name" ) create here @part ! 0 , 0 , ;
: var ( sz "name" ) create @part @ , @part @ cell+ @ ,
                    @part @ cell+ +!  
                    does> dup @ @ swap cell+ @ + ;
: tuple ( n sz "name" ) swap 1- for dup var next drop ;
: part@ ( pt -- pt ) @ ;   : part! ( a pt -- ) ! ;
: part+! ( n a -- ) dup part@ rot + swap part! ;
: size ( a -- ) cell+ @ ;

: singleton ( pt -- )  ðŸº
   here over size allot swap part! ;

part point  âœ´ï¸
  3 cell tuple x y z
: p! ( x y z ) z ! y ! x ! ;
: p? x @ . y @ . z @ . ;
point singleton

: named ( pt "name" -- )  ðŸ“›
   create dup , size allot
   does> dup cell+ swap @ part! ;

point named bob
point named joe
bob 1 2 3 p!
joe 2 3 4 p!
bob p? joe p?
  ðŸ™¤
1 2 3
2 3 4      ðŸ’¯

: stack ( n t "name" )  ðŸ“š
   create 2dup , , 0 , here over part! size * allot ;
: pop ( st -- )
   dup @ size negate swap @ part+! ;
: push ( st -- )
   @ dup part@ over size dup >r over + r> cmove
   dup size swap part+! ;

30 point stack pstack   ðŸ“š
: pdup   pstack push ;
: pdrop   pstack pop ;
: p.   p? pdrop ;
: p+   x @ y @ z @ pdrop
       z +! y +! x +! ;

1 2 3 p! pdup
2 3 4 p! pdup
5 6 7 p! p+
p. cr
p. cr
  ðŸ™¤
 7 9 11
 1 2 3    ðŸ¥ž

But I'm
    ðŸ˜ž
 unsatified...

Make STACK ðŸ“š
  a part?

part stack-part   ðŸ“š
  cell var kind
  cell var start
  cell var items
: stack ( n t "name" )
   stack-part named lastxt execute
   kind ! items !  here start !
   kind @ size items @ * allot
   start @ kind @ part! ;
: stack+! ( n -- ) kind @ size * kind @ part+! ;
: stack-s ( -- a n ) kind @ part@ kind @ size ;
: pop ( st -- ) -1 stack+! ;
: push ( st -- ) stack-s 2dup + swap cmove
                 1 stack+! ;

But still I'm
     ðŸ˜Ÿ
 unsatified...

DISCUSSION
  & QUESTIONS?
      âš˜
  Thank you!
