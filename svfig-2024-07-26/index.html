<!DOCTYPE html>
<script src="../websent/websent.js"></script><script>
FONT = 'consolas; courier';
USABLE = 0.9;
LINE_SPACING = 1.2;
BACKGROUND = '#000000';
FOREGROUND = '#ffffff';
COLORFORTH = true;
</script><pre>

More : Colors ( - More ] Forth
â”„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”„
     [ July 25, 2024

Finding Better Colors
â”„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”„
       : define
       [ execute
       ] compile
       { postpone
       % tag
       ~ variable
       ( comment

Showing Numbers
â”„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”„
Hex: $ff00ff
Decimal: #123

cf x86-64
â”„â”€â”€â”€â”€â”€â”€â”€â”„
â€¢ 64-bit data + return stack.
â€¢ 32-bit addresses and value by default.
â€¢ C "harness" to boot + provide I/O
â€¢ Windows and now Linux support

Language Goals
â”„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”„
â€¢ Try to use Chuck's quirks:
  â—¦ : - ] invert
  â—¦ : or ] xor
  â—¦ : if ( use x86 zero flag, no stack effect
  â—¦ : -if ( use x86 sign flag, no stack effect
  â—¦ : push ] &gt;r : pop ] r&gt;
  â—¦ : @ (  : ! ( etc. use word sized indexing
  â—¦ Use A register, : @+ (  : !+
  â—¦ Emit literals on [ immediate ] to green

Why colorForth?
â”„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”„
â€¢ Forth is about naming some things... ] variable
  â€¢ But implying other things. ] rot + push + pop
  â€¢ It is both mnemonic and pithy.
â€¢ Color is [ joyful!
â€¢ It's even : SIMPLER ( than conventional Forth.
  â€¢ Interpret/compile is just a dispatch table!

create colors
' none ,  ' exec , ' none ,  ' define ,
' comp ,  ' none , ' *comp , ' defer ,
' *exec , ' none , ' none ,  ' none ,
' var ,   ' none , ' none ,  ' none ,
 
:&nbsp;interpret (&nbsp;a n -- )
  0 do
    dup @ dup $f and cells color + @ execute
    cell+
  loop
;

 ( dictionary loop and utils
 : nope ] @nope @ execute ;
 : ,dict ] #4 vocab @ 4/ +! vocab @ 4/ @ 4/ ! ;
 : ?cnot ] lastc @ $f0 and or drop ;
 : ?lit ] $10 ?cnot if $80 ?cnot if ; then then push literal pop ;
 : nah? ( wd-wdf ] 2dup @ ? if or #15 - and ; then nip ? ;
 : find ] nah? if drop 1- 1- find ; then drop nip 1- @ ? ;
 ( implementation of all color tags
 : define ] chere ,dict ,dict ;
 : comp ] ?lit dup push mvocab find if rdrop execute ; then
 ] drop pop dup fvocab find if ,compile drop ; then drop nope ;
 : *comp ] ?lit #5 sar literal ;
 : exec ] dup push fvocab find if rdrop execute ; then drop pop nope ;
 : *exec ] #5 sar ;
 : post ] dup mvocab find if ,compile drop ; then drop nope ;
 : var ] define pop pop pop 1+ dup literal push push push { ; ] ;
 : none ] drop ;

 ( tag dispatch table
 : ,t ] over @tbl ! 1+ ;
 : init ] #0
 ] ' none ,t ' exec ,t ' none ,t ' define ,t
 ] ' comp ,t ' none ,t ' *comp ,t ' post ,t
 ] ' *exec ,t ' none ,t ' none ,t ' none ,t
 ] ' var ,t ' none ,t ' none ,t ' none ,t
 ] drop ;
 [ init
 : 1eval ] @ dup #15 and lastc @
  ] #4 shl over or lastc ! @tbl @ execute ;
 : eval ] over + : loop ] cmp
  ] ifl push dup push 1eval pop 1+ pop loop ; then 2drop ;
 ( interpreter ends here
 : block ] #256 * #0 sys #-128 + $40000 + + ;
 : load ] block #256 eval ;
 : thru ] 2dup #2 + or drop
  ] if push dup push load pop #2 + pop thru ; then drop ;

Registers
â”„â”€â”€â”€â”€â”€â”€â”€â”„
â€¢ RAX - tos
â€¢ RSI - stack pointer
â€¢ RDI - code heap pointer
â€¢ R8 - internal vars - parked sp
  â—¦ R8 +8 - parked hp
  â—¦ R8 +16 - active dictionary
  â—¦ R8 +24 - forth dictionary
  â—¦ R8 +32 - macro dictionary
  â—¦ RCX - temp
â€¢ RDX - "a" register

Dictionary
â”„â”€â”€â”€â”€â”€â”€â”€â”€â”„
0, addr, word, addr, word, addr, word
                                   â†‘
0, addr, word, addr, word        MDICT
                       â†‘
                      FDICT 
                       â†‘
                      DICT

Editor
â”„â”€â”€â”€â”€â”„
â€¢ Modal - ispired by mix of vi and Chuck's
â€¢ Word at a time entry
â€¢ Color toggle, search
â€¢ Clipboard is a stack!

? 1 2 3 4 5 6 7 8 9 0 - + BACK
   q w e r t y u i o p @ ! *
    a s d f g h j k l ; ' ENTER
     z x c v b n m , . /
          SPACE

â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ âœ€
 ğŸŒˆâš¾ğŸ³ï¸â€ğŸŒˆ % r ~ t [ y ( u : i ] o { p ( â–‘ â–‘ â–‘
    â–‘ â–‘ â–‘ğŸ”´ğŸ”â† â†“ â†‘ â†’ â–‘ â–‘ ESC
     â–‘ âœ€ğŸ—â˜ â–‘â‡‡ âğŸ”µâ‡‰ â–‘
          ESC

Bootstrapping Font
â”„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”„
â€¢ 4x6 / 5x6 pixel characters
â€¢ 4 x 6 + 1 (wide) = 25 bit characters
â€¢ 48 character set
â–ˆ...  8         .....  0
â–ˆ...  8         â–ˆ...â–ˆ  1
â–ˆâ–ˆâ–ˆ.  e         .â–ˆ.â–ˆ.  a
â–ˆ..â–ˆ  9         ..â–ˆ..  4
â–ˆ..â–ˆ  9         .â–ˆ.â–ˆ.  a
â–ˆâ–ˆâ–ˆ.  e         â–ˆ...â–ˆ  1
$88e99e         $101a4a1

Variables
â”„â”€â”€â”€â”€â”€â”€â”€â”„
â€¢ Magenta Variables ~ foo ( &nbsp;#0
  â—¦ Place variable in the source block
  â—¦ Makes moving things in editor break
â€¢ Code Variables : foo [ here 0 , ] ;
  â—¦ Places variables in a separate data heap
  â—¦ Allows a resetable default

Flag Conditionals
â”„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”„
â€¢ HARD to get them to stick in your head
â€¢ Sometimes nice when they leave the stack alone
â€¢ But hard to compose several

] x @ 3 or drop if ( x isn't 3 ] then
] x @ ? if ( x is non-zero ] then
] x @ ? -if ( x is negate ] then
] x @ dup 3 or drop if
   ] dup 4 or drop if
     ( x isn't 3 or 4
   ] then
] then drop
] x @ -3 + -if ( x-3 is negative, gotcha ] then
] x @ 3 cmp ifl ( x (signed) less than 3 ] then

Graphics
â”„â”€â”€â”€â”€â”€â”€â”„
â€¢ Want to draw pretty pictures.
â€¢ Want a better [ scalable ( font.
â€¢ Lines, clipping, BÃ©zier curves.

 ( basic box drawing
 : width [ here #1024 , ] ;  : height [ here #768 , ] ;
 : color [ here 0 , ] ;  : x [ here 0 , ] ;  : y [ here 0 , ] ;
 : display ] $2400100 ;
 : row ] width @ * display + ;
 : at ] y ! x ! ;  : +at ] y +! x +! ;  : @at ] x @ y @ ;
 : hline ] push x @ y @ row + pop color @ fill ;
 : rbox ] ? if push dup hline #1 y +! pop 1- rbox ; then 2drop ;
 : box ] dup push rbox pop negate y +! ;
 : screen ] #0 #0 at width @ height @ box ;

 ( graphics stack implementation
 : gstack [ here #100 allot ] ;  : gp [ here gstack , ] ;
 : gpush ] gp @ ! #1 gp +! ;
 : gpop ] #-1 gp +! gp @ @ ;
 : +grf ] x @ gpush y @ gpush color @ gpush ;
 : -grf ] gpop color ! gpop y ! gpop x ! ;

Working with (x, y) values on the stack
â”„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”„
 : rot ] push swap pop swap ;  : -rot ] swap push swap pop ;
 : 2swap ] rot push rot pop ;
 : 2over ] push push 2dup pop pop 2swap ;
 : 4dup ] 2over 2over ;   : 4drop ] 2drop 2drop ;
 : 2push ] pop -rot push push push ;  : 2pop ] pop pop pop rot push ;
 : abs ] ? -if negate then ;

 ( curve drawing
 : rsize ] #20 ;
 : spans [ here height @ rsize * allot ] ;
 : 2sort ] 2dup min push max pop ;
 : rmark ] ? if push dup push @ 2sort @r ! pop 1+ pop 1- rmark ; then 2drop drop ;
 : mark ] ? -if 2drop ; then
 ] dup height @ negate + ? drop -if rsize * spans + rsize rmark ; then 2drop ;
 : rclear ] ? -if drop ; then 0 over mark width @ over mark 1- rclear ;
 : clear ] spans height @ rsize * #-1 #33 shr fill height @ rclear ;
 : ?inwidth ] ? -if 0 ? 2drop ; then
 ] dup width @ negate + ? drop -if ; then 0 ? 2drop ;
 : rstroke ] dup rsize * spans + 1+ rsize 2/ 1-
 : loop ] ? if push dup push @ ?inwidth if dup drop over at
 ] @r dup 1+ @ swap @ negate + #1 box then pop #2 + pop 1- loop ; then 2drop drop ;
 : stroke ] height @ : loop ] ? if 1- dup rstroke loop ; then drop ;

 : pels ] push #20 shl pop ; : /pels ] push #20 sar pop ;
 : ydiff ] nip negate + abs nip ;
 : average ] + 1+ 2/ ;
 : mid ] rot average push average pop ;
 : line ] 4dup ydiff 1- ? -if drop 4drop ; then
 ] 1- ? drop -if mid /pels mark ; then
 ] 4dup mid 2swap 2push 2dup 2push line 2pop 2pop line ;
 : lineto ] 2push @at pels 2pop 2dup at pels line ;

 : square ] dup * ;
 : vsub ] negate rot + push negate + pop ;
 : dist2 ] vsub /pels square swap square + ;

 : 'bezier ] 2swap 2push 4dup dist2 #-9 + ? drop
 ] -if 2pop 2drop line ; then
 ] 2pop 2swap 2dup 2push 2push 2dup 2pop mid
  ] 2dup 2push 2push 2push 2dup 2pop mid
  ] 2dup 2pop mid 2dup 2push 'bezier 2pop 2pop 2pop 'bezier ;
 : bezier ] 2push 2push @at pels 2pop pels 2pop 2dup at pels 'bezier ;

  DEMO +
QUESTIONSâ“
    ğŸ™
 Thank you!
