<!DOCTYPE html>
<script src="../websent/websent.js"></script><script>
FONT = 'consolas; courier';
USABLE = 0.9;
LINE_SPACING = 1.2;
BACKGROUND = '#000000';
FOREGROUND = '#00ff77';
</script><pre>

 Lambdas in Forth
 ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üöÄ  FORTH  DAY  üöÄ
 November 18, 2023

Lambda Expressions
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚Ä¢ Practical variant on lambda calculus
‚Ä¢ Represent an abstract function
‚Ä¢ Ideally a "closure" on its environment

Lambda Calculus
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚Ä¢ Invented by Alonzo Church (1930)
‚Ä¢ Complete model of computation
 
x - a variable 
(Œªx. M) - a lambda abstraction
(M N) - an application

Lisp
‚ïê‚ïê‚ïê‚ïê
‚Ä¢ Lambda calculus inspired Lisp
(lambda (x) (* x x ))

Python: lambda x: x * x
 
  Java: (x) -> x * x
 
   C++: [](int x) { return x * x ; }
 
  Rust: |x| -> x * x
 
 Forth: ?

Closure
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚Ä¢ Ideally lambdas capture their environment
‚Ä¢ Historically dynamically, now lexically
‚Ä¢ Important to make lambdas most useful

(define (adder n)
  (lambda (x) (+ x n)))
 
((adder 3) 4) --> 7

How to do this in Forth?
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚Ä¢ Expand the behavior of locals
‚Ä¢ Add a syntax for starting a closure
‚Ä¢ Sort out the memory management implications

: squarer [: { x } x x * :] ;
4 squarer invoke --> 16

: adder { n } [: { x } x n + :] ;
3 adder constant x
4 x invoke --> 7  

Locals
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚Ä¢ Standardized, but implementation specific innards
‚Ä¢ ¬µEforth and others use the return stack
  - but other approaches possible
‚Ä¢ Issue: local scopes go away on word return
‚Ä¢ Consequence: locals need to move elsewhere

Where to put the locals?
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚Ä¢ Can live long after return
‚Ä¢ Might hold address of lambdas
‚Ä¢ Need to know when to free them

What do others do?
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚Ä¢ Lisp - Garbage Collector
‚Ä¢ Python - Garbage Collector
‚Ä¢ Java - Garbage Collector + optimizer
‚Ä¢ C++ - Stack/Heap + careful lifetimes
‚Ä¢ Rust - Stack/Heap + careful lifetimes

Garbage Collection
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚Ä¢ Free data only when it can't be reached
Three types:
‚Ä¢ Moving / copy collectors (Cheney)
‚Ä¢ Stationary / Mark and Sweep collectors
‚Ä¢ Hybrid collectors

Trade-offs
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚Ä¢ Careful lifetimes - Requires compile-time types
‚Ä¢ Garbage Collector - Requires runtime types
‚Ä¢ Conservative Collector - Might live leak ‚úÖü§∑

Conservative Collection
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚Ä¢ Boehm GC - 1988
‚Ä¢ Treat any value that might be a pointer to
  a GC-ed object as if it is
‚Ä¢ Requires static allocation schemes
‚Ä¢ Allows C garbage collector

Interface
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
pair ( a d -- c )
unpair ( c -- a d )
collect ( -- )
pair? ( c -- f )

Locals in an Environment
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚Ä¢ Instead of allocating stack offset, allocate IDs
‚Ä¢ Create an environment as a chain of pairs of (ID, value)

0 value environment
: init-local! ( id -- ) pair environment swap pair to environment ;
: get-local ( id -- n )
   >r environment
   begin dup while
     unpair unpair
     r@ = if nip rdrop exit then
     drop
   repeat
   rdrop ( zero on stack )
;

Implementing [: :]
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚Ä¢ [: - save scope, jump over code
‚Ä¢ :] - exit, land from jump, bind code + environment

: adder { n } [: { x } x n + :] ;
((n-val . n-id) . xt)

Filling it Out
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚Ä¢ Make TO work, setting the environment
‚Ä¢ Make RECURSE work, saving the environment

(define (factorial n)
  (define (fact! n)
    (if (= n 0)
       1
       (* (factorial (- n 1)) n)))
  (fact! n))

: factorial { n }
   0 { fact! }
   [: { n }
      n 0= if
         1
      else
         n 1- fact! invoke n *
      then
   :] to fact!
   n fact! invoke
;

(define (factorial2 n)
  (define (iter product counter)
     (if (> counter n)
        product
        (iter (* counter product) (+ counter 1))))
  (iter 1 1))

: factorial2 { n }
   0 { iter }
   [: { product counter }
      counter n > if
         product
      else
         counter product * counter 1+ iter invoke
      then
   :] to iter
   1 1 iter invoke
;

: cons { a d } [: if d else a then :] ;
: car ( c ) 0 swap invoke ;
: cdr ( c ) 1 swap invoke ;

: gcd2 { a b } b 0= if a else b a b mod recurse then ;
: make-rat { n d }
   n d gcd2 { g }
   n g / d g / cons ;
: numer ( r ) car ;
: denom ( r ) cdr ;
: print-rat { x } x numer . ." / " x denom . ;

: add-rat { x y } x numer y denom * y numer x denom * +
                  x denom y denom * make-rat ;
: sub-rat { x y } x numer y denom * y numer x denom * -
                  x denom y denom * make-rat ;
: mul-rat { x y } x numer y numer *
                  x denom y denom * make-rat ;
: div-rat { x y } x numer y denom *
                  x denom y numer * make-rat ;
: equal-rat? { x y } x numer y denom * y numer x denom * = ;

DEMO

QUESTIONS‚ùì
    üôè
 Thank you!
